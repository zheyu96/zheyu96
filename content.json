{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"writing","text":"","link":"/writing/index.html"}],"posts":[{"title":"C++與STL入門","text":"tags: 演算法入門經典disqus: hackmd UVA - 00101 The Blocks Problem AC code題目簡述:vector應用想法:如果照題目的每個指令分別寫動作，會寫得很長(且不易debug) HINT:觀察四個指令 .blue { color:blue; } .red { color:red ; } .green { color:green; } .black { color:black; } 在將a搬到b上之前，先將a和b上的積木放回原來的位置 在將a搬到b所在的那堆積木之上之前，先將a上的積木放回原來的位罝 將a本身和其上的積木一起放到b上，在搬之前b上方的積木放回原位 說穿了就是判斷a,b(使用者輸入的號碼)所在的位址，指定範圍搬運(挪移)，指定範圍恢復原狀ㄎㄎ突然變得容易許多(良好的選定策略，能將實作code複雜程度and複雜度降低)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;int n;vector &lt;int&gt; v[30];void find(int a,int &amp;p,int &amp;h){ for(p=0;p&lt;n;p++) for(h=0;h&lt;v[p].size();h++) if(v[p][h]==a) return;}void clear(int p,int h){ for(int i=h+1;i&lt;v[p].size();i++){ int ss=v[p][i]; v[ss].push_back(ss); } v[p].resize(h+1);}void go(int p1,int h,int p2){ for(int i=h;i&lt;v[p1].size();i++) v[p2].push_back(v[p1][i]); v[p1].resize(h);} int main(){ int a,b; while(cin&gt;&gt;n){ string s1,s2; for(int i=0;i&lt;n;i++) v[i].push_back(i); while(cin&gt;&gt;s1){ if(s1==\"quit\"){ for(int i=0;i&lt;n;i++){ cout&lt;&lt;i&lt;&lt;\":\"; for(int j=0;j&lt;v[i].size();j++){ cout&lt;&lt;\" \"&lt;&lt;v[i][j]; } cout&lt;&lt;\"\\n\"; v[i].resize(0); } break; } cin&gt;&gt;a&gt;&gt;s2&gt;&gt;b; int pa,pb,ha,hb; find(a,pa,ha); find(b,pb,hb); if(pa==pb) continue; if(s2==\"onto\") clear(pb,hb); if(s1==\"move\") clear(pa,ha); go(pa,ha,pb); } } } 心得:*在實作時，一直卡在如何將搜尋a,b位址打包成在一起回傳(後來發現原來可以把函式宣告成vector&lt;int,int&gt;型態)或者如本題一樣用成&amp;位址(只是這個東西我不太知道怎麼解釋,待處理)然後原本寫法是一直pop_back，後來發現直接resize就好(一次解決) 相關語法資源整理*C/C++ - Vector (STL) 用法與心得完全攻略[C++] STL 容器 (二) - Iterator然後有一個好像很新的東東(我這題沒用到，下題會出現)–autoC++ 程式語言 auto 自動變數類型語法教學與範例 UVA - 10815 Andy’s First Dictionary AC code題目簡述:set應用(感覺比較像字串處理+排序)沒有想法(直接暴力做) 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;set &lt;string&gt; dict;int main(){ string a,buf; while(getline(cin,a)){ for(int i=0;i&lt;a.length();i++){ if(isalpha(a[i])) a[i]=tolower(a[i]); else a[i]=' '; } stringstream ss(a); while(ss&gt;&gt;buf) dict.insert(buf); } for(auto i:dict){ cout&lt;&lt;i&lt;&lt;\"\\n\"; }} 心得:這題看到許多神奇的輸出入，感覺這題就單純字串處理和set實作相關語法資源整理tolower語法stringstream用法整理前面的寒訓講義也有 UVA - 00156 AnanagramsAC code題目簡述:給一段文章，抓取其單詞，不管大小寫、字母順序，都無法變成同一文章的其他詞(map應用)想法就利用剛剛學的tolower統一大小寫，並將字母做排序(e.g. APPLE-&gt;aelpp)並透過map資料結構的特性做檢索 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;map &lt;string,int&gt; cnt;vector &lt;string&gt; word;string st (string a){ string ans=a; for(int i=0;i&lt;a.length();i++) ans[i]=tolower(ans[i]); sort(ans.begin(),ans.end()); return ans;}int main(){ string s; while(cin&gt;&gt;s){ if(s[0]=='#') break; word.push_back(s); string r=st(s); if(!cnt.count(r)) cnt[r]=0; cnt[r]++; } vector &lt;string&gt; ans; for(int i=0;i&lt;word.size();i++) if(cnt[st(word[i])]==1) ans.push_back(word[i]); sort(ans.begin(),ans.end()); for(int i=0;i&lt;ans.size();i++) cout&lt;&lt;ans[i]&lt;&lt;\"\\n\";} 相關語法資源整理C/C++ - Map (STL) 用法與心得完全攻略 UVA - 12096The SetStack Computer題目簡述set的set之操作(e.g.並集、交集…..應用) 註:PUSH、DUP、ADD指令待釐清* 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define ALL(x) x.begin(),x.end()#define INS(x) inserter(x,x.begin())typedef set&lt;int&gt; SET;map&lt;SET,int&gt; id_forsets; //sets的id資料庫 vector&lt;SET&gt; sets; int id(SET x){ //尋找是否已建檔，否則建立賦予新id if(id_forsets.count(x)) return id_forsets[x]; sets.push_back(x); return id_forsets[x]=sets.size()-1; } int main(){ stack&lt;int&gt; s; //題目中的堆疊 int qq; //測資數量 cin&gt;&gt;qq; while(qq--){ int n; //指令數量 cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ string move; cin&gt;&gt;move; //動作輸入 if(move==\"PUSH\") s.push(id(SET())); //丟一個新的進去 else if(move==\"DUP\") s.push(s.top()); // else{ SET x1=sets[s.top()]; s.pop(); SET x2=sets[s.top()]; s.pop(); SET x; if(move==\"UNION\") set_union(ALL(x1),ALL(x2),INS(x)); //並集 if(move==\"INTERSECT\") set_intersection(ALL(x1),ALL(x2),INS(x)); //交集 if(move==\"ADD\"){ x=x2; x.insert(id(x1));} s.push(id(x)); } cout&lt;&lt;sets[s.top()].size()&lt;&lt;\"\\n\"; } cout&lt;&lt;\"***\\n\"; }} 心得這題真的不太好懂，連我也是一頭霧水相關語法資源整理[解題] UVa - 12096 The SetStack ComputerC++中STL用法總結【轉】UVA.12096 The SetStack Computer ( 好题 栈 STL混合应用)","link":"/2021/12/25/stl/"},{"title":"data_structure","text":"資料結構===UVA - 10082 WERTYU AC code題目簡述:鍵盤打字時，都剛好不小心往右打了一格，將它還原想法:用陣列建對應表，用if做對應表太冗(且不易閱讀) 1234567891011121314#include&lt;iostream&gt;using namespace std;char t[]={\"`1234567890-=QWERTYUIOP[]\\\\ASDFGHJKL;'ZXCVBNM,./\"};int main(){ char a; while((a = getchar()) != EOF){ if(a==' '||a=='\\n')putchar(a); else{ int j; for(j=0;t[j]!=a;j++); putchar(t[j-1]); } }} 心得:原先是使用getline，但後來發現換行符號會被吃掉導致WA，似乎還沒有string可以接收’\\n’還能輸出的函式，只好回去用char讀取輸出輸入相關語法整理: 2020一中資訊社寒訓05：字串與IO摘要:C++裡getline()、get()、cin、getchar區別 UVA - 401 PalindromesAC code題目簡述:輸入一字串，判斷是否為回文詞及鏡像詞，並輸出其種類想法這題蠻複雜的，尤其是網路上對於鏡像詞的解法，都搞得好複雜(還有用if一一對照的)，回文就是簡單的一一比對而已 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;string ans[4]={\" -- is not a palindrome.\",\" -- is a regular palindrome.\",\" -- is a mirrored string.\",\" -- is a mirrored palindrome.\"};string mi={\"A 3 HIL JM O 2TUVWXY51SE Z 8 \"};char rrr(char st){ if(isalpha(st)) return mi[st-'A']; else if(st=='0') return mi[14]; else return mi[st-'0'+25];}int main(){ string a; while(cin&gt;&gt;a){ int b=1,m=1; for(int i=0;i&lt;(a.length()+1)/2;i++){ if(a[i]!=a[a.length()-1-i]) b=0; if(rrr(a[i])!=a[a.length()-1-i]) m=0; } cout&lt;&lt;a&lt;&lt;ans[m*2+b]&lt;&lt;\"\\n\"&lt;&lt;\"\\n\"; //m*2+b這技巧..orz } } 心得:我個人對於m*2+b這個技巧感到佩服，因為它直接省掉好幾個if;然後注意0和O在題目裡面是視為一樣。然後這題要很小心鏡像詞的表很容易打錯(QQ) 省思與想法 我發現隨著題目愈來愈困難，必須將解題過程記錄下來，並撰寫題解，以及思索更好的解題方式(才能在競賽時把coding的過程降低失誤率)而許多題目看似有著複雜的輸出入，但只要有巧妙的作法，便能將題目迎刃而解。 而要將做法練得更巧妙，除了認真刷題外，也可多參考網友們的題解或和同儕、老師討論，並對於寫過的AC Code隨時翻出來解討是否有更加解法。","link":"/2021/12/25/data-structure/"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"c++","slug":"c","link":"/tags/c/"}],"categories":[]}